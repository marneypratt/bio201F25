---
title: "2 Factor Analysis Example"
format: 
  html:
    code-overflow: wrap
    embed-resources: true
editor_options: 
  chunk_output_type: inline
---

## Load necessary packages

Run the code below at the start of the session to make sure all the necessary packages are loaded.

It is recommended that you put all your code to load packages in one R chunk at the start. Run the chunk below by clicking the little green arrow at the top right of the code chunk.

```{r}
#| label: setup
#| warning: false
#| message: false

suppressPackageStartupMessages(
  library(tidyverse)) ## for readr, dplyr, ggplot2
library(ggbeeswarm) ## for jittering points (you can remove this is you did not use a dotplot)
#library(flextable, warn.conflicts = FALSE) ## for making formatted tables that can be pasted elsewhere
library(rstatix, warn.conflicts = FALSE) #pipe friendly framework for basic stats
library(ggpubr, warn.conflicts = FALSE) #publication ready plots & QQ plots
library(labelled) #for labeling variables better
library(glue) #for making labels
library(ggstats) #for gglikert() to make nice bar graphs for survey questions

```

## Example 2 Factor Dataset

The data used here are from a student project where HRV was measured for 19 subjects. All of the subjects had their HRV measured for 5 minutes while doing nothing (=Baseline) and while completing a small jigsaw puzzle. 

Half of the subjects were told to take their time to complete the puzzle (Treatment A), and the other half were timed and encouraged to be as fast as possible (Treatment B). 

Thus, the dependent variable is any of the HRV variables, and there are two independent variables - (1) the time the HRV was measured (Baseline or Puzzle) and (2) the treatment group (A - unstressed by time, or B - stressed by time).

Since there is one measurement variable (a measure of HRV), and two nominal variables (time of measurement, treatment), we can use a 2-Factor analysis to see if time pressure has a different effect on HRV than no time pressure.

Because the same subject was measured twice (Baseline and Puzzle), we have to take that into account. 

The students who did this project predicted that time pressure would stimulate the sympathetic nervous system which could impact HRV. 

We will start by importing the data files by running the code below.

```{r}
#| label: import data

#Import data file 
my.df <- read_csv("data/example-data/puzzle/HRVdata.csv",
                  show_col_types = FALSE)
                 
#Change independent categorical variables to factors
my.df$test.period <- factor(my.df$test.period, 
                             levels = c("Baseline", "Puzzle"))
my.df$treatment <- factor(my.df$treatment, 
                          levels = c("A", "B"))

# Modify factor levels
levels(my.df$treatment) <- c("Unstressed", "Time Stressed")

subjects <- read_csv("data/example-data/puzzle/subjects.csv")

metadata <- read_csv("data/example-data/puzzle/variable_metadata.csv")

#create variable labels using the labelled package
variable_labels <- metadata |> 
  select(variable, variable_label) |> 
  deframe()

#add labels to data
my.df <- my.df |> 
  left_join(subjects) |> 
  set_variable_labels(!!!variable_labels)


# for more help with labeling data see   
# https://www.pipinghotdata.com/posts/2022-09-13-the-case-for-variable-labels-in-r/    

```

Take a look at the dataset we just created by clicking on "my.df" in the Environment tab in the upper right RStudio window.

Note that this dataset, which we named "my.df" (for "my data frame", which is just a generic way to name a data frame making it easier to use template or example code), includes a tidy data spreadsheet. Each column has a column name and a more descriptive label that we added using the `set_variable_labels` function from the `labelled` package.

Next we will relabel some of our variables so they can easily be used with the template code and avoid rewriting the column names a lot of times.


```{r}
#| label: define variables
#Define your variables and redefine your dataframe name here to avoid having to type them a lot

#define the continuous variable of choice 
cont.var <- "SDNN" 

#define the categorical variable that is your within-subjects factor 
w.factor.var <- "test.period"

#define the categorical variable that is your between-subjects factor 
b.factor.var <- "treatment"

#define the name of the column that contains your subject identifiers
subject.ID <- "subject"



```


## Data Exploration

### Descriptive Statistics

First, let's get the full descriptive statistics by running the next code chunk.

Note that we will use the 2 factors in the `group_by()` function to see the descriptive statistics for the interaction of these two factors.

```{r}
#| label: descriptive stats

# the code below will calculate descriptive statistics for a variable of interest grouped by another variable


# the code below will calculate descriptive statistics for a variable of interest grouped by another variable

df.sum <- my.df  |>  
  # remove missing values from continuous variables
  filter(!is.na(.data[[cont.var]])) |> 
  
  # Group the data by your 2 factors
  group_by(.data[[b.factor.var]], .data[[w.factor.var]]) |> 
  
  # calculate the descriptive stats
  summarize(mean = mean(.data[[cont.var]]), 
            median = median(.data[[cont.var]]), 
            SD = sd(.data[[cont.var]]), 
            IQR = IQR(.data[[cont.var]]), 
            min = min(.data[[cont.var]]),
            max = max(.data[[cont.var]]),
            N = n())

df.sum



```

How should we round these variables? Recall that you can use the SD as the indicator of how much average variability there is in your data. For this class, please round the SD to 2 significant digits based on recommendations in [Cole et al. (2015)](https://www-ncbi-nlm-nih-gov.libproxy.smith.edu/pmc/articles/PMC4483789/). Then round all the other values to the same decimal place as the rounded SD.

```{r}
#| label: rounding the SD


#calculate rounded SD
my.df |> 
  
  # replace the blank with the categorical variable(s)
  group_by(.data[[b.factor.var]], .data[[w.factor.var]]) |> 
  
  # remove missing values 
  filter(!is.na(.data[[cont.var]])) |> 
  
  #calculate the rounded values
  summarise(SD = signif(sd(.data[[cont.var]]), digits=2))

```


In the case above, we should round the SD to the tenths or ones place to get it rounded to 2 significant digits (there is more variation in the After measurements). Thus, we should round the values to the tenths place for the Before groups and to the ones place for the After groups. But to simplify, we will round them all to the tenths place for this example. We can always round the After values to the ones place later.

```{r}
#| label: rounded descriptive stats

# Use the following for digits in the `round` function
# 
#    rounding to the tens place use digits=-1
#    rounding to the ones place use digits=0
#    rounding to the tenths place use digits=1
#    rounding to the hundredths place use digits=2

#set the number of digits to round to based on the rules above (this blank should be just a number)
round.digit <- 0


# replace the blank with the cleaned data frame name 
my.df  |>  
  # remove missing values from continuous variables
  filter(!is.na(.data[[cont.var]])) |> 
  
  #this groups by a defined set of between and within subjects factors
  #remove factors as needed
  group_by(.data[[b.factor.var]], .data[[w.factor.var]] )  |> 
  
  # calculate the descriptive stats
  # do not place anything in the empty parentheses in the n() 
  summarize(Sample.size = n(),
            Min = round(min(.data[[cont.var]]), digits=round.digit),
            Q1 = round(quantile(.data[[cont.var]], .25), digits=round.digit),
            Median = round(median(.data[[cont.var]]), digits=round.digit),
            Q3 = round(quantile(.data[[cont.var]], .75), digits=round.digit),
            Max = round(max(.data[[cont.var]]), digits=round.digit),
            Mean = round(mean(.data[[cont.var]]), digits=round.digit),              
            SD = signif(sd(.data[[cont.var]]), digits=2))

```



### QQ Plots to Assess Normality

Use a QQ plot to see if each continuous variable is normally distributed. Since we only have one continuous dependent variable in this example, that is the only variable we need to assess the distribution for.

The `color` and `facet.by` functions splits the plots up by any factors you have. If you have no factors, then delete one or both of those lines and the comma from the above line.


```{r}
#| label: Dependent variable QQ plots 

#make a QQ plot for each dependent variable that is continuous
ggpubr::ggqqplot(
  data = my.df,               #put the data frame name here 
  x = {{ cont.var }},                  #put the continuous variable name here
  color = {{ b.factor.var }},       #put the between subjects factor here (remove if no factors)
  facet.by = {{ w.factor.var }}  #put the within subjects factors here (remove if no factors)
  )  

```

If the points are fairly close to the line, you can assume that the data have a reasonably normal distribution.

If the points do not fit close to the line at all, you can try a transformation (such as taking the logarithm) to see if that gets the points to fit closer to the line. Just note that you can't take the log of zero, so if you have any zero values, you can add one before taking the log (or use the function `log1p`)

Here we can see that the points fit the line okay other than a couple points, so we can assume it is close enough to a normal distribution. 

Let's look for outliers next.

```{r}
#| label: identify outliers 

#test for outliers
outliers <- my.df  |> 
  group_by(.data[[w.factor.var]], .data[[b.factor.var]] )  |> 
  rstatix::identify_outliers({{ cont.var }}) 

outliers 

```

If an outlier is extreme, you may decide to run the analysis with and without the outlier(s) to see the impact on the results. Since these two outliers are not extreme, we will leave them in but it is good to note.

```{r}
#| label: remove outliers 

#if you want to remove an outlier
#fill in the blank with the number of the subject you want to remove
#remove the hashtags in front of the code below

my.df <- my.df |>
  dplyr::filter(subject != 6)


```

If you want to report any of the descriptive statistics, it really is not necessary to report all of them. Since this dataset is reasonably normal, we can use the mean and SD to summarize the data.

```{r}
#| label: formatted table

#see https://davidgohel.github.io/flextable/ for more info & formatting options

#calculate descriptive stats
#replace the blank below with the name of the dataframe
df.sum <- my.df |> 
  
  # replace the blank with the categorical variable(s)
  group_by(.data[[b.factor.var]], .data[[w.factor.var]] )  |>  
  
  # remove missing values 
  filter(!is.na(.data[[cont.var]])) |> 
  
  # calculate the descriptive stats
  # replace the blanks with the number of digits 
  # to the right of the decimal place based on the rounded SD
  # the SD is rounded to 2 significant digits using signif  
  # do not place anything in the empty parentheses in the n() 
  # N represents the sample size within each group
  summarise(Mean = round(mean(.data[[cont.var]]), digits=0), 
            SD = signif(sd(.data[[cont.var]]), digits=2),
            N = n())

library(flextable) #helps format a nicer table

#create the formatted table
ft <- flextable(df.sum,
                cwidth = 0.75) |>  #can vary cell width as needed
  
  #bold the headings
  bold(part = "header") |> 
  
  #center columns
  align(align = "center", part = "all" )

#print the table
#right click on the table, choose select all, 
#choose copy, then paste in your document
#finish formatting as needed in your document
ft

```




## Inferential Statistics

Next, we want to perform some inferential statistical tests to see if the dependent variable was impacted by the two independent variables. Since this experimental design used the same subjects, we need to take that into consideration using a repeated measures type of test.

### Graph the 2-Factor Plot

First we will graph all the data on a 2-factor plot

```{r}
#| label: two-factor plot

#create 2 factor plot 
factor2.plot <- ggplot(
  data = my.df, 
  aes(
    y = .data[[cont.var]], 
    x = .data[[w.factor.var]],
    group = .data[[subject.ID]])) +
  geom_point(size = 3, color = "orange", alpha = 0.8) +
  geom_line(color = "grey86") + 
  
  ###this bit of code adds the horizontal bar - use median or mean as needed
  stat_summary(fun = mean, fun.min = mean, fun.max = mean, 
      geom = "crossbar", width = 0.3, linewidth = 0.6,
      aes(group = '.data[[w.factor.var]]' )) +
  
  xlab("Time of Measurement") +
  ylab("SDNN (ms)") +
  theme_classic(base_size=18) +
  facet_grid(~.data[[b.factor.var]])
factor2.plot


ggsave(factor2.plot, filename="results/examples/two-factor/factor2.plot.png",  
       height = 5, width = 8, units = "in", 
       dpi = 300)


```
The graph shows the data points connected by lines for each subject as well as the mean value for each treatment given as the thick horizontal bar. 

### Compare the baseline between treatment groups

For the first inferential test, we will compare the baseline values between the two treatments (A vs B) to make sure that we did a good job of random sampling. Our expectation is that there should **not** be a difference between the treatments for the baseline values before they experienced the treatments.

```{r}
#| label: unpaired comparison of baselines


#set the formula to use the defined variables 
#this makes it easier to change the variables at the top and rerun everything 
#without having to retype the variables in every code chunk
response <- cont.var
predictor <- b.factor.var
formula_string <- paste0(response, " ~ ", predictor)
formula_object <- as.formula(formula_string)

#computes the effect size using Cohen's d

my.df.base <- my.df  |>  
  filter(test.period == "Baseline") 

baseline.effectSize.results <- 
  rstatix::cohens_d(
           data = my.df.base,
           formula_object, 
           paired = FALSE,       #TRUE for within-subjects, FALSE for between-subjects
           var.equal = FALSE,   #TRUE for equal variance, FALSE for unequal variance
           hedges.correction = TRUE,
           ci = TRUE,
           conf.level = 0.95,
           ci.type = "bca",
           nboot = 1000)
baseline.effectSize.results


baseline.effect.plot <- baseline.effectSize.results  |>    
  ggplot(aes(
    x = .y., 
    y = effsize)) +
  
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high),
                  size = 1, # Adjust point size
                  linewidth = 0.8, # Adjust line thickness
                  color = "steelblue") + # Set color
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") + # Add a reference line at 0
  xlab("Unstressed - Time Stressed") +
  ylab("Standardized Effect Size") +
  #additional formatting
  theme_classic(base_size = 14)  +  #sets the font size
  theme(axis.text.x = element_blank()) +
  theme(legend.position = "none")   #controls legend/key

baseline.effect.plot
  
```
Remember to look at the magnitude of the effect (scroll all the way to the right or click on baseline.effectSize.results in the Environment) and record the effect size (effsize) and the 95% CI (conf.low and conf.high). If the 95% CI includes zero, then the effect is not significantly different from zero (which is what we predicted for the two groups at baseline).

### Between Subjects Difference Plot

Next, we will graph the difference in the within subjects factor which is Time of Measurement (Puzzle - Baseline) for each treatment 

```{r}
#| label: difference plot 


#first we need to change the format of the data from long to wide
#this way, we will have one row for each subject and can take a difference
#between the after and before values
my.df.wide  <- my.df |> 
  dplyr::select(.data[[subject.ID]], .data[[b.factor.var]], .data[[w.factor.var]], .data[[cont.var]]) |> 
  pivot_wider(
    names_from = .data[[w.factor.var]],

    values_from = .data[[cont.var]]
  )

#next, take the difference between the values for each subject
my.df.diff <- my.df.wide |> 
  mutate(change.cont.var = Puzzle - Baseline)
  

#create difference plot 
difference.plot <- ggplot(
  data = my.df.diff, 
  aes(
    y = change.cont.var, 
    x = .data[[b.factor.var]])) +
  geom_point(size = 3, color = "orange", alpha = 0.8) +

  ###this bit of code adds the horizontal bar - use median or mean as needed
  stat_summary(fun = mean, fun.min = mean, fun.max = mean, 
      geom = "crossbar", width = 0.2, linewidth = 0.6,
      aes(group = 'time.measured' )) +
  
  #these two lines make the nicer axis labels (include units!)
  xlab("Treatment") +
  ylab("Difference in SDNN (ms)") +
  
  
  theme_classic(base_size=16) 


difference.plot


ggsave(difference.plot, filename="results/examples/two-factor/difference.plot.png",  
       height = 5, width = 4, units = "in", 
       dpi = 300)

```

This graph shows the difference between the Baseline and Puzzle time periods for subjects separated by treatment (time stressed or unstressed) with each point representing the difference for a subject and the horizontal bar is the mean for each treatment.


### Effect Size Comparing Between Subjects Difference (Interaction)

```{r}
#| label: between subjects effect size

#set the formula to use the defined variables 
#this makes it easier to change the variables at the top and rerun everything 
#without having to retype the variables in every code chunk
response <- "change.cont.var"
predictor <- b.factor.var
formula_string <- paste0(response, " ~ ", predictor)
formula_object <- as.formula(formula_string)


#computes the effect size using Cohen's d for Welch test
btw.effectSize.results <- 
  rstatix::cohens_d(
    data = my.df.diff,           #put the dataframe name here
    formula_object,      #continuous variable ~ factor 
    paired = FALSE,       #TRUE for within-subjects, FALSE for between-subjects
    var.equal = FALSE,   #TRUE for equal variance, FALSE for unequal variance
    hedges.correction = TRUE,
    ci = TRUE,
    conf.level = 0.95,
    ci.type = "bca",
    nboot = 1000)
btw.effectSize.results

effect.plot <- btw.effectSize.results  |>    
  ggplot(aes(
    x = .y., 
    y = effsize)) +
  
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high),
                  size = 1, # Adjust point size
                  linewidth = 0.8, # Adjust line thickness
                  color = "steelblue") + # Set color
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") + # Add a reference line at 0
  xlab("Unstressed - Time Stressed") +
  ylab("Standardized Effect Size") +
  #additional formatting
  theme_classic(base_size = 14)  +  #sets the font size
  theme(axis.text.x = element_blank()) +
  theme(legend.position = "none")   #controls legend/key

effect.plot


ggsave(effect.plot, filename="results/examples/two-factor/effect.plot.png",  
       height = 5, width = 3, units = "in", 
       dpi = 300)

```

Remember to look at the magnitude of the effect (scroll all the way to the right or click on the object made that gives the effect size results in the Environment) and record the effect size (effsize) and the 95% CI (conf.low and conf.high). If the 95% CI includes zero, then the effect is not significantly different from zero (which is what we predicted for the two groups at baseline).

We also made a graph that shows the effect size results visually. In this case, the point represents the value of the effect size that you chose (Cohen's d, Cohen's d for Welch test, or the Wilcoxon paired signed-rank test) and the vertical lines represent the 95% confidence interval calculated using the adjusted bootstrap percentile (BCa) method.

If the 95% CI includes zero (shown by crossing over the dotted line), then that effect size is not significantly different from zero (meaning there is no evidence of an effect). Does either vertical blue line touch or cross the dotted zero line?

### Main Effects

If the interaction of treatment and time of measurement is not significant, we can look at the main effects. 

Without splitting by treatment, let's look at the main effect of time of measurement.

```{r}
#| label: main plot time

#create 2 factor plot 
main.time.plot <- ggplot(
  data = my.df, 
  aes(
    y = .data[[cont.var]], 
    x = .data[[w.factor.var]],
    group = .data[[subject.ID]])) +
  geom_point(aes(color = treatment, shape = treatment), 
              size = 3, alpha = 0.9) +
  geom_line(color = "grey86") + 
  
  ###this bit of code adds the horizontal bar - use median or mean as needed
  stat_summary(fun = mean, fun.min = mean, fun.max = mean, 
      geom = "crossbar", width = 0.2, linewidth = 0.6,
      aes(group = 'test.period' )) +
  
  xlab("Time of Measurement") +
  ylab("SDNN (ms)") +
  theme_classic(base_size=18)  + 
  labs(shape = "Treatment", color = "Treatment" ) +
  theme(legend.position = "top")
  
  main.time.plot <- ggpubr::ggpar(main.time.plot, palette = c("#EE7733", "#0077BB"))

  
main.time.plot


ggsave(main.time.plot, filename="results/examples/two-factor/main.time.plot.png",  
       height = 5, width = 5, units = "in", 
       dpi = 300)

```
This graph shows the main effect of Time of Measurement without splitting by Treatment (while the points for each treatment are given a different color or shape, the means are for both treatments together within each time period).


```{r}
#| label: time main effect size

#set the formula to use the defined variables 
#this makes it easier to change the variables at the top and rerun everything 
#without having to retype the variables in every code chunk
response <- cont.var
predictor <- w.factor.var
formula_string <- paste0(response, " ~ ", predictor)
formula_object <- as.formula(formula_string)


#computes the effect size using Cohen's d for Welch test
time.effectSize.results <- 
  rstatix::cohens_d(
    data = my.df,           #put the dataframe name here
    formula_object,      #continuous variable ~ factor 
    paired = TRUE,       #TRUE for within-subjects, FALSE for between-subjects
    var.equal = FALSE,   #TRUE for equal variance, FALSE for unequal variance
    hedges.correction = TRUE,
    ci = TRUE,
    conf.level = 0.95,
    ci.type = "bca",
    nboot = 1000)
time.effectSize.results


time.effect.plot <- time.effectSize.results  |>    
  ggplot(aes(
    x = .y., 
    y = effsize)) +
  
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high),
                  size = 1, # Adjust point size
                  linewidth = 0.8, # Adjust line thickness
                  color = "steelblue") + # Set color
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") + # Add a reference line at 0
  xlab("Baseline - Puzzle") +
  ylab("Standardized Effect Size") +
  #additional formatting
  theme_classic(base_size = 14)  +  #sets the font size
  theme(axis.text.x = element_blank()) +
  theme(legend.position = "none")   #controls legend/key

time.effect.plot

ggsave(time.effect.plot, filename="results/examples/two-factor/time.effect.plot.png", 
       height = 5, width = 3, units = "in", 
       dpi = 300)

```


```{r}
#| label: main plot treatment

#create 2 factor plot 
main.trt.plot <- ggplot(
  data = my.df, 
  aes(
    y = .data[[cont.var]], 
    x = .data[[b.factor.var]])) +
  geom_point(aes(color = .data[[w.factor.var]], shape = .data[[w.factor.var]]), 
              size = 3, alpha = 0.9) +

  ###this bit of code adds the horizontal bar - use median or mean as needed
  stat_summary(fun = mean, fun.min = mean, fun.max = mean, 
      geom = "crossbar", width = 0.2, linewidth = 0.6) +
  
  xlab("Treatment") +
  ylab("SDNN (ms)") +
  theme_classic(base_size=18)  +
  labs(shape = "Test Period", color = "Test Period" ) +
  theme(legend.position = "top")
  
  main.trt.plot <- ggpubr::ggpar(main.trt.plot, palette = c("#EE7733", "#0077BB"))

  
main.trt.plot


ggsave(main.trt.plot, filename="results/examples/two-factor/main.trt.plot.png",  
       height = 5, width = 5, units = "in", 
       dpi = 300)

```


```{r}
#| label: treatment main effect size

#set the formula to use the defined variables 
#this makes it easier to change the variables at the top and rerun everything 
#without having to retype the variables in every code chunk
response <- cont.var
predictor <- b.factor.var
formula_string <- paste0(response, " ~ ", predictor)
formula_object <- as.formula(formula_string)


#computes the effect size using Cohen's d for Welch test
trt.effectSize.results <- 
  rstatix::cohens_d(
    data = my.df,           #put the dataframe name here
    formula_object,      #continuous variable ~ factor 
    paired = FALSE,       #TRUE for within-subjects, FALSE for between-subjects
    var.equal = FALSE,   #TRUE for equal variance, FALSE for unequal variance
    hedges.correction = TRUE,
    ci = TRUE,
    conf.level = 0.95,
    ci.type = "bca",
    nboot = 1000)
trt.effectSize.results


trt.effect.plot <- trt.effectSize.results  |>    
  ggplot(aes(
    x = .y., 
    y = -effsize)) +
  
  geom_pointrange(aes(ymin = -conf.low, ymax = -conf.high),
                  size = 1, # Adjust point size
                  linewidth = 0.8, # Adjust line thickness
                  color = "steelblue") + # Set color
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") + # Add a reference line at 0
  xlab("Time Stressed - Unstressed") +
  ylab("Standardized Effect Size") +
  #additional formatting
  theme_classic(base_size = 14)  +  #sets the font size
  theme(axis.text.x = element_blank()) +
  theme(legend.position = "none")   #controls legend/key

trt.effect.plot

```

## Survey Results

You can also make graphs that show the results from the survey(s) you had your subjects answer. 

Go to the script_templates folder then select the graphing subfolder followed by the bar_graphs subfolder. You might also want to look at the example analysis to see how survey results can be presented.

```{r}
#| label: survey results

#first we need to change the format of the data from long to wide
#this way, we will have one row for each subject and can take a difference
#between the after and before values
my.df.wide  <- my.df |> 
  dplyr::select(.data[[subject.ID]], .data[[b.factor.var]], .data[[w.factor.var]], .data[[cont.var]]) |> 
  pivot_wider(
    names_from = .data[[w.factor.var]],

    values_from = .data[[cont.var]]
  )

#next, take the difference between the values for each subject
my.df.diff <- my.df.wide |> 
  mutate(change.cont.var = Puzzle - Baseline) |> 
  left_join(subjects)

likert_levels <- 1:5

likert_labels <- c(
  "Very Negative",
  "Negative",
  "Neutral",
  "Positive",
  "Very Positive"
)

my.df.diff$feeling.before <- factor(my.df.diff$feeling.before, 
                        levels = likert_levels, 
                        labels = likert_labels, 
                        ordered = TRUE)

my.df.diff$feeling.after <- factor(my.df.diff$feeling.after,
                        levels = likert_levels, 
                        labels = likert_labels, 
                        ordered = TRUE)

likert_labels2 <- c(
  "Very Low",
  "Low",
  "Neutral",
  "High",
  "Very High"
)

my.df.diff$energy.before <- factor(my.df.diff$energy.before, 
                        levels = likert_levels, 
                        labels = likert_labels2, 
                        ordered = TRUE)

my.df.diff$energy.after <- factor(my.df.diff$energy.after, 
                        levels = likert_levels, 
                        labels = likert_labels2, 
                        ordered = TRUE)

my.df.diff$caffeine.regular <- factor(my.df.diff$caffeine.regular, 
                          levels = c("No", "Sometimes", "Yes"))


my.df.diff <- my.df.diff |>
    set_variable_labels(
      energy.before = "Subject energy level before doing the puzzle",
      energy.after = "Subject energy level after doing the puzzle",
      feeling.before = "How subjects felt before doing the puzzle",
      feeling.after = "How subjects felt after doing the puzzle",
      sleep = "Do you generally get enough sleep?", 
      satiated = "Have you had enough to eat today?", 
      like.puzzles = "Do you like puzzles?",
      caffeine.regular = "Do you regularly drink something caffeinated?"
    )

energy.survey <- gglikert(my.df.diff, include = c(energy.before, energy.after),
         add_totals = FALSE,
         y_label_wrap = 25,
         facet_rows = vars(treatment))
energy.survey 

feeling.survey <- gglikert(my.df.diff, include = c(feeling.before, feeling.after),
         add_totals = FALSE,
         y_label_wrap = 25,
         facet_rows = vars(treatment))
feeling.survey

caff.survey <-gglikert(my.df.diff, include = c(caffeine.regular),
         add_totals = FALSE,
         y_label_wrap = 25,
         facet_rows = vars(treatment))
caff.survey

binary.survey <- gglikert(my.df.diff, include = c(sleep, satiated, like.puzzles),
         add_totals = FALSE,
         y_label_wrap = 25,
         labels_color = "black",
         facet_rows = vars(treatment)) +
  scale_fill_manual(values = c("#C8B0D9", "#7DBA8A"))

binary.survey


ggsave(energy.survey, filename="results/examples/two-factor/energy.survey.png", 
       height = 4, width = 6, units = "in", 
       dpi = 300)

ggsave(feeling.survey, filename="results/examples/two-factor/feeling.survey.png", 
       height = 4, width = 6, units = "in", 
       dpi = 300)

ggsave(caff.survey, filename="results/examples/two-factor/caff.survey.png", 
       height = 4, width = 6, units = "in", 
       dpi = 300)

ggsave(binary.survey, filename="results/examples/two-factor/binary.survey.png", 
       height = 4, width = 6, units = "in", 
       dpi = 300)


```





## Finishing Up

Any graph files you save using the `ggsave()` function should appear in the results folder within the project folder.

If you are working on the Smith server, you will first need to export this file to your computer (it is simplest to do one graph at a time):

-   Check the box next to the graph file

-   Go to the "More" menu with the gear icon and click the drop down arrow

-   Select "Export" and then save the file to your computer

You can now insert your graphs into your Group Folder and Group Presentation so everyone in your group has access to the graphs you made.


### R & Package Versions and Citation Information

In addition to citing journal articles and other references, in a full scientific paper you should cite what software was used for the analysis.

While it will not be a requirement to cite R and the packages used in the results slide show, you should have all the packages and their versions in your records (this rendered quarto document will be kept as that record).

Optionally, you can refer to [How to Cite R](https://docs.google.com/presentation/d/1RG4_R-MDOy1vbMz-M1gfOcMtgqWu9Kvv_R4ex5QdcVk/edit?usp=sharing) if you want to know how to cite in the text as well as the full citation in the Literature Cited section at the end of a scientific paper.

Run the code below to get a full record of the version of R and all packages used.


```{r}
#| label: sessionInfo

sessionInfo()

```

It is good to have a record of the actual citation information for R and the packages used.

Use the code below to get the information to cite R itself

```{r}
#| label: cite R

#citation info for base R 
citation()

```

Use the code below to cite the {tidyverse} package and then repeat the code replacing "tidyverse" with any other packages you need to cite

```{r}
#| label: citing packages

citation("tidyverse")
citation("ggpubr")
citation("rstatix")
citation("labelled")
citation("ggstats")

```

### Render this File to HTML & Print to PDF

Don't forget to "render" your .qmd file when you are done.

-   Before you Render

    -   Make sure that each code chunk has an unique label name or no name

    -   Save this file and give it the name "projectAnalysis_YourName.qmd" (replace your name with the "YourName" part)

-   Render this Quarto file to HTML (just select the Render menu item at the top of this window)

-   If the HTML file didn't already open in your browser, then click on the name of the file in the Files window and select "View in Web Browser"

-   Once the HTML file is open in your web browser, then use the print function within your browser to save it as a PDF. Please name your PDF file "projectAnalysis_YourName.pdf" (again, replace your name with the "YourName" part)

-   Make sure the PDF file is saved somewhere on your computer that you can get to

-   Place a copy of the PDF file in your GROUP Google Drive folder for this class

