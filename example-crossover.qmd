---
title: "projectAnalysis_YourName"
subtitle: "BIO 201 Project Data Analysis"
author: "Your Name"
date: "November , 2025"
format: 
  html:
    code-overflow: wrap
    embed-resources: true
---

## Load necessary packages

Run the code below at the start of the session to make sure all the necessary packages are loaded. If you add any packages, put them in this same code chunk and put a comment next to it for what you used it for.

It is recommended that you put all your code to load packages in one R chunk at the start. Run the chunk below by clicking the little green arrow at the top right of the code chunk.

```{r}
#| label: setup
#| warning: false
#| message: false

suppressPackageStartupMessages(
  library(tidyverse)) ## for readr, dplyr, ggplot2
library(rstatix, warn.conflicts = FALSE) #pipe friendly framework for basic stats
library(ggpubr, warn.conflicts = FALSE) #publication ready plots & QQ plots
library(labelled) #for labeling variables better
library(ggstats) #for gglikert() to make nice bar graphs for survey questions


```


Copy, paste, and tweak the necessary script templates into the code chunks below.


## Import Data


```{r}
#| label: import data


#replace the blank below with the name of your HRV data
#make sure that you put the .csv file into data folder
my.df <- read_csv("data/example-data/nature/crossover_data.csv",
                  show_col_types = FALSE)

#Change independent categorical variables to factors
#replace the blanks after my.df$ with the column name of the 
#independent categorical variable 
#(make sure to use the same column name on the same line)
#replace the blanks in quotes with the levels within each column
#make sure you put the levels in the right order 
#for example 
#my.df$time.measured <- factor(my.df$time.measured, levels = c("Before", "After"))
my.df$treatment <- factor(my.df$treatment, 
                    levels = c("Scrolling", "Nature"))


#replace the blank below with the name of your subjects data
#make sure that you put the .csv file into data folder
subjects <- read_csv("data/example-data/nature/subjects.csv")


#replace the blank below with the name of your metadata file
##make sure that you put the .csv file into data folder
metadata <- read_csv("data/example-data/nature/variable_metadata.csv")


#create variable labels using the labelled package
variable_labels <- metadata |> 
  select(variable, variable_label) |> 
  deframe()

#add labels to data
my.df <- my.df |> 
  left_join(subjects) |> 
  set_variable_labels(!!!variable_labels)


```

Make sure your data imported correctly by looking at it. 

Next we will relabel some of our variables so they can easily be used with the template code and avoid rewriting the column names a lot of times.

Replace **ONLY** the blanks in the code below as instructed

```{r}
#| label: define variables

#Define your variables here to avoid having to type them as much

#define the continuous variable of choice 
cont.var <- "SDNN" 

#define the categorical variable that is your within-subjects factor column name
#remove this line if you do not have a within-subjects factor
w.factor.var <- "treatment"

#define the categorical variable that is your between-subjects factor column name
##remove this line if you do not have a between-subjects factor
b.factor.var <- "sequence"

#define the name of the column that contains your subject identifiers
subject.ID <- "subject"



```



## Data Exploration


For this section, look in the script_templates folder and then data_exploration subfolder for the necessary script templates. 

### QQ Plots to Assess Normality

Check to see if the continuous dependent variable is normally distributed. 

```{r}
#| label: Continuous dependent variable QQ plots 

## make sure to have the ggpubr package loaded to get this code to run


#make a QQ plot for each dependent variable that is continuous
ggpubr::ggqqplot(
  data = my.df,               #put the data frame name here 
  x = {{ cont.var }},                  #put the continuous variable name here
  color = {{ w.factor.var }},       #put the within subjects factor here (remove if no factors)
) 


```


### Check for outliers

Let's look for outliers next.

```{r}
#| label: identify outliers 

## make sure to have the rstatix package loaded  
## and the variables defined to get this code to run



#test for outliers
my.df  |> 
  
  #this groups by a defined set of between and within subjects factors
  #remove factors as needed
  group_by(.data[[w.factor.var]], .data[[b.factor.var]] )  |> 
  
  
  rstatix::identify_outliers({{ cont.var }}) 


```


The result above shows how many rows (if any) contain outliers. If it says 0 rows, that would indicate that there were no outliers. 

You may want to click on the little "Show in new window" icon at the top right of the results to see the whole table of results more easily. Either way, make sure you fully scroll to the right to see the last column in the results labeled "is.extreme". If there are any extreme outliers, you may want to filter those subjects out and rerun the descriptive statistics. 

If there are no extreme outliers, then delete the code chunk below. If there are outliers that you remove, you must note that you removed them and why in your results (you might want to look at the information about the subject to see if you can see why they were an outlier or make sure you wrote the values down correctly in the original spreadsheet). You may want to run the analysis with and without the outlier(s) so see how they impact the results.

```{r}
#| label: remove outliers

#if you want to remove an outlier
#fill in the blank with the number of the subject you want to remove
#you can remove more than one by adding subject != ___ more than once
#within the filter function separated by a comma
#dplyr::filter(subject != ___, subject != ___)


# df <- df |> 
#   dplyr::filter(subject != ___)


```


### Descriptive Statistics

I recommend starting with the script to give you all the descriptive statistics. Then you will have everything in your notes in case you need them later. 

```{r}
#| label: descriptive stats

# the code below will calculate descriptive statistics for a variable of interest grouped by another variable
# the dplyr package must be loaded before this will work
# the variables included here need to be defined to get this code to run


df.sum <- my.df  |>  
  # remove missing values from continuous variables
  filter(!is.na(.data[[cont.var]])) |> 
  
  #this groups by a defined set of between and within subjects factors
  #remove factors as needed
  group_by(.data[[w.factor.var]])  |> 
  
  # calculate the descriptive stats
  # you don't need to change anything below 
  # leave the parentheses for n() empty
  summarize(Mean = mean(.data[[cont.var]]), 
            Median = median(.data[[cont.var]]), 
            SD = sd(.data[[cont.var]]), 
            IQR = IQR(.data[[cont.var]]), 
            Min = min(.data[[cont.var]]),
            Max = max(.data[[cont.var]]),
            Sample.size = n())

df.sum


```

Paste in the template code for rounding the SD below

```{r}
#| label: rounding the SD

# the code below will calculate standard deviation for a variable of interest 
# grouped by up to two factors (remove any factors as needed)
# the SD will be rounded to two significant figures
# the dplyr package must be loaded before this will work
# the variables included here need to be defined to get this code to run

#calculate rounded SD
my.df |> 
  
  #this groups by a defined set of between and within subjects factors
  #remove factors as needed
  group_by(.data[[w.factor.var]])  |> 
  
  # remove missing values 
  filter(!is.na(.data[[cont.var]])) |> 
  
  #calculate the rounded values
  summarise(SD = signif(sd(.data[[cont.var]]), digits=2))



```

Round the descriptive statistics to the same decimal place as the rounded SD values given above.

```{r}
#| label: rounded descriptive stats

# the code below will calculate descriptive statistics for a variable of interest grouped by another variable
# the dplyr package must be loaded before this will work
# the variables included here need to be defined to get this code to run


# Use the following for digits in the `round` function
# 
#    rounding to the tens place use digits=-1
#    rounding to the ones place use digits=0
#    rounding to the tenths place use digits=1
#    rounding to the hundredths place use digits=2

#set the number of digits to round to based on the rules above (this blank should be just a number)
round.digit <- 1


# replace the blank with the cleaned data frame name 
my.df  |>  
  # remove missing values from continuous variables
  filter(!is.na(.data[[cont.var]])) |> 
  
  #this groups by a defined set of between and within subjects factors
  #remove factors as needed
  group_by(.data[[w.factor.var]])  |> 
  
  # calculate the descriptive stats
  # do not place anything in the empty parentheses in the n() 
  summarize(Sample.size = n(),
            Min = round(min(.data[[cont.var]]), digits=round.digit),
            Q1 = round(quantile(.data[[cont.var]], .25), digits=round.digit),
            Median = round(median(.data[[cont.var]]), digits=round.digit),
            Q3 = round(quantile(.data[[cont.var]], .75), digits=round.digit),
            Max = round(max(.data[[cont.var]]), digits=round.digit),
            Mean = round(mean(.data[[cont.var]]), digits=round.digit),              
            SD = signif(sd(.data[[cont.var]]), digits=2))


```


If you decide you want a formatted table of a subset of the descriptive statistics, then load the `flextable` package in the setup code chunk at the start of this Quarto file and then add a code chunk to make the desired formatted table below.



### HRV Graph

Let's graph the HRV variable. 

```{r}
#| label: HRV graph

#use this code to make a 2 factor plot 
#with one within subjects factor and 
#one between subjects factor
#the ggplot2 package must be loaded for this code to work


#make the plot

line.plot <- ggplot(
  data = my.df, 
  aes(
    y = .data[[cont.var]], 
    x = .data[[w.factor.var]],
    group = .data[[subject.ID]])) +
  geom_point(size = 2, color = "orange", alpha = 0.8) +
  geom_line(color = "grey86") + 
  
  ###this bit of code adds the horizontal bar - use median or mean as needed
  stat_summary(fun = mean, fun.min = mean, fun.max = mean, 
               geom = "crossbar", width = 0.2, linewidth = 0.6,
               aes(group = '.data[[w.factor.var]]' )) +
  
  #nicer labels for axis labels (not needed here because using column labels)
  #xlab("___") +  #within subjects factor label
  #ylab("___") + #dependent variable label with units

  theme_classic(base_size=14) 

line.plot

# save the graph! (.png or .jpg file types are recommended)
ggsave(filename = "results/HRVgraph.png",  
       plot = line.plot,   #put the object name of your plot here
       height = 5, width = 7, units = "in", 
       dpi = 300)

```

Make sure you have included proper axis titles that include units where needed. Make sure to also use the correct measure of central tendency (mean if data are normal, median if data are not normal). You can change the stat_summary code above from mean to median as needed.




## Inferential Statistics

### Effect Size Calculations and Graph

To pick the right test, we need to determine if the distribution is normal and if the variance is equal.

-   **Normal Distribution, Equal Variance:** If the data is normal, and the two groups have similar dispersion (i.e. similar variance), then you should use "regular" **Cohen's d effect size (*d*)**

-   **Unequal Variance:** If the data has unequal dispersion (i.e. unequal variance), then you should use the **Cohen's d for Welch test effect size (*d*)**

-   **Non-normal Distribution, Equal Variance:** If the data is NOT normal but the two groups have similar dispersion (i.e. similar variance), then you should use the **Wilcoxon effect size (*r*)** (note that some statisticians recommend to use the Cohen's d for Welch test effect size if the variance is very different even if the distribution is not normal)

Select the correct effect size from the script templates based on your data. You will find the templates in script_templates and then the inference subfolder


```{r}
#| label: effect size

#to run this code, make sure the rstatix package is loaded
#make sure you have also already defined your variables (cont.var & b.factor.var)


#set the formula to use the defined variables 
#this makes it easier to change the variables at the top and rerun everything 
#without having to retype the variables in every code chunk
response <- cont.var
predictor <- w.factor.var
formula_string <- paste0(response, " ~ ", predictor)
formula_object <- as.formula(formula_string)

#computes the effect size using Cohen's d
#can change the var.equal option for equal or unequal variance as needed

crossover.effectSize.results <- 
  rstatix::cohens_d(
    data = my.df,
    formula_object, 
    paired = TRUE,       #TRUE for within-subjects, FALSE for between-subjects
    var.equal = FALSE,   #TRUE for equal variance, FALSE for unequal variance
    hedges.correction = TRUE,
    ci = TRUE,
    conf.level = 0.95,
    ci.type = "bca",
    nboot = 1000)

crossover.effectSize.results


#graph the results to make it easier to visualize
crossover.effect.plot <- crossover.effectSize.results  |>    
  ggplot(aes(
    x = .y., 
    y = -effsize)) +
  
  geom_pointrange(aes(ymin = -conf.low, ymax = -conf.high),
                  size = 1, # Adjust point size
                  linewidth = 0.8, # Adjust line thickness
                  color = "steelblue") + # Set color
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") + # Add a reference line at 0
  
  #nicer axis labels
  xlab("Nature - Scrolling") +
  ylab("Standardized Effect Size") +
  
  #additional formatting
  theme_classic(base_size = 14)  +  #sets the font size
  theme(axis.text.x = element_blank()) +
  theme(legend.position = "none")   #controls legend/key

crossover.effect.plot


# save the graph (.png or .jpg file types are recommended)
ggsave(filename = "results/crossover.effect.plot.png",    #give your graph a name you will remember
       plot = crossover.effect.plot,   #put the object name of your effect size graph here
       height = 5, width = 3, units = "in", 
       dpi = 300)

```

Remember to look at the magnitude of the effect (scroll all the way to the right or click on the object made that gives the effect size results in the Environment) and record the effect size (effsize) and the 95% CI (conf.low and conf.high). If the 95% CI includes zero, then the effect is not significantly different from zero (which is what we predicted for the two groups at baseline).

We also made a graph that shows the effect size results visually. In this case, the point represents the value of the effect size that you chose (Cohen's d, Cohen's d for Welch test, or the Wilcoxon paired signed-rank test) and the vertical lines represent the 95% confidence interval calculated using the adjusted bootstrap percentile (BCa) method.

If the 95% CI includes zero (shown by crossing over the dotted line), then that effect size is not significantly different from zero (meaning there is no evidence of an effect). 


## Survey Results

You can also make graphs that show the results from the survey(s) you had your subjects answer. 

Go to the script_templates folder then select the graphing subfolder followed by the bar_graphs subfolder. You might also want to look at the example analysis to see how survey results can be presented.

```{r}
#| label: survey results

#make sure `ggstats` is installed and loaded

#first we need to change the format of the data from long to wide
#this way, we will have one row for each subject and can take a difference
#between the after and before values
my.df.wide  <- my.df |> 
  dplyr::select(.data[[subject.ID]], .data[[b.factor.var]], .data[[w.factor.var]], .data[[cont.var]]) |> 
  pivot_wider(
    names_from = .data[[w.factor.var]],

    values_from = .data[[cont.var]]
  )

#next, take the difference between the values for each subject
my.df.diff <- my.df.wide |> 
  mutate(change.cont.var = Nature - Scrolling) |> 
  left_join(subjects)

likert_levels <- 1:5

likert_labels <- c(
  "Very Negative",
  "Negative",
  "Neutral",
  "Positive",
  "Very Positive"
)

my.df.diff$feeling <- factor(my.df.diff$feeling, 
                        levels = likert_levels, 
                        labels = likert_labels, 
                        ordered = TRUE)


likert_labels2 <- c(
  "Very Low",
  "Low",
  "Neutral",
  "High",
  "Very High"
)

my.df.diff$energy <- factor(my.df.diff$energy, 
                        levels = likert_levels, 
                        labels = likert_labels2, 
                        ordered = TRUE)


my.df.diff$caffeine.regular <- factor(my.df.diff$caffeine.regular, 
                          levels = c("No", "Sometimes", "Yes"))


my.df.diff <- my.df.diff |>
    set_variable_labels(
      energy = "Subject energy level before the experiment",
      feeling = "How subjects felt before the experiment",
      sleep = "Do you generally get enough sleep?", 
      satiated = "Have you had enough to eat today?", 
      like.nature = "Do you like spending time in nature?",
      caffeine.regular = "Do you regularly drink something caffeinated?"
    )

energy.survey <- gglikert(my.df.diff, include = c(energy),
         add_totals = FALSE,
         y_label_wrap = 25)
energy.survey 

feeling.survey <- gglikert(my.df.diff, include = c(feeling),
         add_totals = FALSE,
         y_label_wrap = 25)
feeling.survey

caff.survey <-gglikert(my.df.diff, include = c(caffeine.regular),
         add_totals = FALSE,
         y_label_wrap = 25)
caff.survey

binary.survey <- gglikert(my.df.diff, include = c(sleep, satiated, like.nature),
         add_totals = FALSE,
         y_label_wrap = 25,
         labels_color = "black") +
  scale_fill_manual(values = c("#C8B0D9", "#7DBA8A"))

binary.survey



# save the graph (.png or .jpg file types are recommended)
ggsave(filename="results/cross.energy.survey.png", 
       plot = energy.survey,   #put the object name of your survey bar graph here
       height = 1.5, width = 6, units = "in", 
       dpi = 300)

# save the graph (.png or .jpg file types are recommended)
ggsave(filename="results/cross.feeling.survey.png", 
       plot = feeling.survey,   #put the object name of your survey bar graph here
       height = 1.5, width = 6, units = "in", 
       dpi = 300)

# save the graph (.png or .jpg file types are recommended)
ggsave(filename="results/cross.caff.survey.png", 
       plot = caff.survey,   #put the object name of your survey bar graph here
       height = 1.5, width = 6, units = "in", 
       dpi = 300)

# save the graph (.png or .jpg file types are recommended)
ggsave(filename="results/cross.binary.survey.png", 
       plot = binary.survey,   #put the object name of your survey bar graph here
       height = 2.5, width = 6, units = "in", 
       dpi = 300)


```



## Finishing Up

Any graph files you save using the `ggsave()` function should appear in the results folder within the project folder.

If you are working on the Smith server, you will first need to export this file to your computer (it is simplest to do one graph at a time):

-   Check the box next to the graph file

-   Go to the "More" menu with the gear icon and click the drop down arrow

-   Select "Export" and then save the file to your computer

You can now insert your graphs into your Group Folder and Group Presentation so everyone in your group has access to the graphs you made.


### R & Package Versions and Citation Information

In addition to citing journal articles and other references, in a full scientific paper you should cite what software was used for the analysis.

While it will not be a requirement to cite R and the packages used in the results slide show, you should have all the packages and their versions in your records (this rendered quarto document will be kept as that record).

Optionally, you can refer to [How to Cite R](https://docs.google.com/presentation/d/1RG4_R-MDOy1vbMz-M1gfOcMtgqWu9Kvv_R4ex5QdcVk/edit?usp=sharing) if you want to know how to cite in the text as well as the full citation in the Literature Cited section at the end of a scientific paper.

Run the code below to get a full record of the version of R and all packages used.


```{r}
#| label: sessionInfo

sessionInfo()

```

It is good to have a record of the actual citation information for R and the packages used.

Use the code below to get the information to cite R itself

```{r}
#| label: cite R

#citation info for base R 
citation()

```

Use the code below to cite the {tidyverse} package and then repeat the code replacing "tidyverse" with any other packages you need to cite

```{r}
#| label: citing packages

citation("tidyverse")
citation("ggpubr")
citation("rstatix")
citation("labelled")
citation("ggstats")

```

### Render this File to HTML & Print to PDF

Don't forget to "render" your .qmd file when you are done.

-   Before you Render

    -   Make sure that each code chunk has an unique label name or no name

    -   Save this file and give it the name "projectAnalysis_YourName.qmd" (replace your name with the "YourName" part)

-   Render this Quarto file to HTML (just select the Render menu item at the top of this window)

-   If the HTML file didn't already open in your browser, then click on the name of the file in the Files window and select "View in Web Browser"

-   Once the HTML file is open in your web browser, then use the print function within your browser to save it as a PDF. Please name your PDF file "projectAnalysis_YourName.pdf" (again, replace your name with the "YourName" part)

-   Make sure the PDF file is saved somewhere on your computer that you can get to

-   Place a copy of the PDF file in your GROUP Google Drive folder for this class

